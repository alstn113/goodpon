## 선착순 쿠폰 발급 성능 개선

### 1. DB 병목 개선

1. 일단 쿠폰 발급 수 쓰기 락으로 조회 -> 쿠폰 발급 -> 쿠폰 발급 수 증가 -> 락 해제
2. 먼저 쿠폰 발급 수를 원자적 증가(UPDATE ... WHERE :maxIssueCount > issueCount 쿼리) -> 성공 시 쿠폰 발급
3. Redis를 사용하고 Lua Script로 발급 수 증가 원자적 처리 -> Redis 장애 시 DB에서 쿠폰 발급, 사용 내역 재집계
    - 1, 2번에서 사용하던 DB 발급 수, 사용 수 테이블은 제거

* 인덱스, 트랜잭션, 락 설정, 커넥션 풀 등 개선
* 커넥션 풀: 서버에서 DB에 연결할 커넥션 미리 만들어 재사용
    * MySQL: max connections 151개, 서버의 HikariCP connection 기본값 10개, 커넥션 너무 크면 부하
* 스레드 풀: tomcat thread pool, 서버에서 요청 처리할 스레드 미리 만들어 재사용
    * 스레드 풀 크기: CPU 코어 수 * 2 + 1, CPU 코어 수가 8개면 17개
    * 비동기: 워커 스레드 CPU 코어 수 근처 (8~32개)

### 2. 메세지 큐 사용 (아직 잘 모르는 부분)

- 서버 과부하 방지, 정합성 유지, 트래픽 버스트에도 유실/중복 없이 처리 가능

1. 쿠폰 발급 요청 -> kafka -> 쿠폰 발급 순차 처리 

### 3. WebFlux, Coroutines, R2DBC 등 비동기 처리로 서버 처리량 개선

- I/O Wait(네트워크, DB 쿼리 대기)
    - WebFlux, 코루틴 등은 스레드를 반환
    - CPU/애플리케이션 리소스 낭비 없이 동시성↑
- 락 대기(DB 쿼리가 락에 막혀 대기)
    - 논블로킹 서버 스레드는 반환
    - DB 커넥션 자체는 락 해제까지 계속 사용 중, 커넥션 풀 고갈에 주의 필요